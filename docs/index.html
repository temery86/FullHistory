<!DOCTYPE html>
<head>
<title>Time Use Simulation</title>
<link rel="stylesheet" href="style/style.css" type="text/css" media="screen" />
<link rel="stylesheet" type="text/css" href="//cloud.typography.com/7626174/696048/css/fonts.css" />
<link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
<meta charset="utf-8">
<style>

.node {
  stroke-width: 1.5px;
}

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote,
pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd,
q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt,
dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot,
thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption,
footer, header, hgroup, menu, nav, output, ruby, section, summary, time,
mark, audio, video {
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline
}

article, aside, details, figcaption, figure, footer, header, hgroup,
menu, nav, section {
    display: block
}

body {
    line-height: 1
}

@font-face {
    font-family: "GGPFont";
    src:url("Fonts/PFDinTextPro-Light.ttf");
}

ol, ul {
    list-style: none
}

blockquote, q {
    quotes: none
}

blockquote:before, blockquote:after, q:before, q:after {
    content: '';
    content: none
}

table {
    border-collapse: collapse;
    border-spacing: 0
}

#main-wrapper {
    font-family: "GGPFont", Gill Sans, sans-serif;
    font-size: 14px;
    width: 1090px;
    margin: 0 auto 0 auto;
}

h1 {
    font-family: "GGPFont", Gill Sans, sans-serif;
    font-size: 24px;
    font-style: normal;
    text-transform: uppercase;
    margin-bottom: 10px;
    text-align: center
}

h3 {
    text-transform: uppercase;
    font-size: 1em;
    padding: 3px 0;
    margin: -5px 0 3px
}

img {
    display: block;
    margin-left: 20px;
    margin-top: 10px;
    width: 10%;
    float: left;
}

.centered {
    text-align: center
}

#sidebar {
    width: 259px;
    float: left;
    margin-right: 30px;
    padding-right: 20px;
    border-right: 1px solid #ccc;
    height: 730px
}

#current_time {
    font-family: "GGPFont", Gill Sans, sans-serif;
    font-size: 60px;
    color: #666;
    text-align: center;
    margin: 10px auto 0 auto;
    width: 250px;
}

#chart {
    float: left
}

#speed {
    font-family: "GGPFont", Gill Sans, sans-serif;
    font-size: 16px;
    width: 203px;
    margin: 15px auto 25px
}

#speed .togglebutton {
    padding: 3px;
    text-align: center;
    border: 1px solid #ccc;
    cursor: pointer;
    float: left;
    width: 60px
}

#speed .togglebutton.slow {
    border-right: 0
}

#speed .togglebutton.fast {
    border-left: 0
}

#speed .togglebutton.current {
    color: #fff;
    background: #000;
    border: 1px solid #000
}

#note {
    position: relative;
    top: 0;
    color: #fff;
    font-family: "GGPFont", Gill Sans, sans-serif;
    font-weight: 400;
    font-size: 1.2em;
    line-height: 1.3em;
    text-align: center;
    height: 100px;
    width: 750px;
    margin: 0 auto 0 auto;
}

.x.axis text {
    font-size: 1.3em;
}

.x.grid line {
    stroke: #000;
    opacity: .2
}

.y.axis text {
    font-size: 1.3em;
    alignment-baseline: middle
}

#cite {
    border-top: 1px solid #ccc;
    padding-top: 20px;
    top: 640px;
    font-size: 12px;
    line-height: 1.4em;
    width: 259px
}

circle {}

.line {
    stroke-width: .1px
}

a {
    color: #821122;
    text-decoration: none;
    border-bottom: 1px solid #ccc
}

a:hover {
    border-bottom: 1px solid #821122
}

.clr {
    clear: both
}

path.domain {
    display: none
}


</style>
</head>
<body>
<div id="main-wrapper">

<img  src="ggp_logo_hq.png" >

<div id="current_time">Age: 15.0</div>
<div id="speed">
<div class="togglebutton slow" data-val="slow">Slow</div>
<div class="togglebutton medium current" data-val="medium">Medium</div>
<div class="togglebutton fast" data-val="fast">Fast</div>
<div class="clr"></div>
</div>
<div id="note"> &nbsp;</div>
<div id="chart"></div>
<div class="clr"></div>
</div>
<script src="d3-3-5-5.min.js"></script>
<script>
var USER_SPEED = "medium";

var margin = {top: 105, right: 50, bottom: 50, left: 160 },
    width = 1090 - margin.left - margin.right,
	  height = 550 - margin.top - margin.bottom,
    padding = 3, // separation between nodes
    radius = 3.5,
    damper = 0.35;

// var width = 780,
//     height = 800,
// 	padding = 1,
// 	maxRadius = 3;
// 	// color = d3.scale.category10();
	
var sched_objs = [],
	curr_month = 0;
var last_month = 300;

// Simplified
var mstat_codes = {
	"m": {"short": "Married", "desc": "Married"},
	"c": {"short": "Cohabiting", "desc": "Cohabiting"},
	"s": {"short": "Single", "desc": "Single"},
};

// Short versions.
var group_names = {
	"0":	{ "name": "Group0", color: "#007d81", count: 0 },
	"1":	{ "name": "Group1", color: "#f58220", count: 0 },
	"2":	{ "name": "Group2", color: "#38c40a", count: 0 },
	"3":	{ "name": "Group3", color: "#dd5a62", count: 0 },
	"4":	{ "name": "Group4", color: "#eca0a5", count: 0 },
}

var pstat_names = {
	"0":	{ "name": "No Child", color: "#6b8ef7", count: 0 },
	"1":	{ "name": "1 Child", color: "#05b1b5", count: 0 },
	"2":	{ "name": "2 Children", color: "#38c40a", count: 0 },
	"3":	{ "name": "3 Children", color: "#dd5a62", count: 0 },
	"4":	{ "name": "4+ Children", color: "#eca0a5", count: 0 }, /*
	"5":	{ "name": "Five Children", color: "#fedc5b", count: 0 },
	"6":	{ "name": "Six Children", color: "#cf6001", count: 0 }, */
}


var speeds = { "slow": 1000, "medium": 250, "fast": 100 };

var time_notes = [
	{ "start_month": 10, "stop_month": 280, "note": "In this GGS data visualisation you see the partnership and fertility histories of a random sample of 500 individuals from Sweden (Source: GGS Sweden 2012). The two colors represent two different cohorts: green for 1942-46, orange for 1968-72. For more info visit: www.ggp-i.org" },
];
var notes_index = 0;


// // Activity to put in center of circle arrangement
// var center_act = "Traveling",
// 	center_pt = { "x": 380, "y": 365 };
//
//
// // Coordinates for activities
// var foci = {};
// mstat_codes.forEach(function(code, i) {
// 	if (code.desc == center_act) {
// 		foci[code.index] = center_pt;
// 	} else {
// 		var theta = 2 * Math.PI / (mstat_codes.length-1);
// 		foci[code.index] = {x: 250 * Math.cos(i * theta)+380, y: 250 * Math.sin(i * theta)+365 };
// 	}
// });

var x = d3.scale.ordinal()
    .rangePoints([50, width]);
var xAxis = d3.svg.axis()
    .scale(x)
    .tickFormat(function(d) {
        return pstat_names[d]['name'];
    })
    .orient("top");
// var xGrid = d3.svg.axis()
// 	.scale(x)
//     .orient("bottom")
//     .innerTickSize(-(height+margin.top));
    // .tickPadding(10);
	
var y = d3.scale.ordinal()
	.domain(Object.keys(mstat_codes))
    .rangePoints([0, height-100]);
var yAxis = d3.svg.axis()
	.scale(y)
	.tickSize(40)
	.tickFormat(function(d) {
		console.log(Object.keys(mstat_codes));
		return mstat_codes[d]['desc'];
	})
	.orient("left");


// Start the SVG
var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


// Load data and let's do it.
d3.tsv("FH_real_data.csv", function(error, data) {	
	
	var labels = [0, 1, 2, 3, 4]
	
	//
    // Axes
	//
	
	// replace labels with the following commented expression to reset to the original
	// code which was dynamic and changed the number of labels to set it equal to the
	// number of unique groups in the dataset.
	
	// d3.map(data, function(d) { return d.grp; }).keys()
	
	x.domain(labels);
    svg.append("g")
        .attr("class", "y axis")
		.attr("transform", "translate(-70,-10)")
		.call(yAxis)
 	  .selectAll(".tick text")
    	.call(wrap, 80);
	svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0,-100)")
		.call(xAxis)
     .selectAll(".tick text")
        .call(wrap, x.rangeBand());
	
	
	// 
	// Counters
	//
	
	/*
	
	var counter = svg.selectAll(".counter")
		.data(Object.keys(pstat_names))
	  .enter().append("g")
		.attr("class", "counter")
		.attr("transform", function(d) { return "translate("+x(d)+",-60)"; })
	  .append("text")
		.attr("text-anchor", "middle")
		.text(function(d,i) { 
			if (i == 0) {
				return "With Child " + readablePercent(pstat_names[d].count); 
			} else {
				return readablePercent(pstat_names[d].count); 
			}
		});
	
	*/
	
	//
	// Store data
	//
	data.forEach(function(d) {
		var hist_array = d.code.split(",");
		var activities = [];
		for (var i=0; i < hist_array.length; i++) {
			// Duration
			if (i % 2 == 1) {
				activities.push({
					'grp': d.group, 
					'numchildren': hist_array[i-1].substring(1), 
					'mstat': hist_array[i-1].substring(0, 1), 
					'duration': +hist_array[i]});
			}
		}
		sched_objs.push(activities);
	});
	
	
	// A node for each person's schedule
	var nodes = sched_objs.map(function(o,i) {
		var init = o[0];
		var init_x = x(init.numchildren) + Math.random();
		var init_y = y(init.mstat) + Math.random();
		var col = colorByGroup(init.grp)
		group_names[init.grp].count += 1;
		return {
			grp: init.grp,
			numchildren: init.numchildren,
			mstat: init.mstat,
			radius: radius,
			x: init_x,
			y: init_y,
			color: col,
			moves: 0,
			next_move_time: init.duration,
			sched: o,
		}
	});

	var force = d3.layout.force()
		.nodes(nodes)
		.size([width, height])
		.gravity(0)
		.charge(0)
		.friction(.9)
		.on("tick", tick)
		.start();

	var circle = svg.selectAll("circle")
		.data(nodes)
	  .enter().append("circle")
		.attr("r", function(d) { return d.radius; })
		.style("fill", function(d) { return d.color; });
	
		

	// Update nodes based on activity and duration
	function timer() {
		d3.range(nodes.length).map(function(i) {
			var curr_node = nodes[i],
				curr_moves = curr_node.moves;
			var curr_grp = 0

			// Time to go to next activity
			if (curr_node.next_move_time == curr_month) {
				if (curr_node.moves == curr_node.sched.length-1) {
					curr_moves = 0;
				} else {
					curr_moves += 1;
				}
				
				// Keep track of working and not working
				if (curr_node.numchildren == "w" && curr_node.sched[ curr_moves ].numchildren != "k") {
					pstat_names[curr_node.grp].count -= 1;
				} else if (curr_node.numchildren == "w" && curr_node.sched[ curr_moves ].numchildren == "k") {
					pstat_names[curr_node.grp].count += 1;
				}
			
				// Move on to next activity
				curr_node.numchildren = curr_node.sched[ curr_moves ].numchildren;
				curr_node.mstat = curr_node.sched[ curr_moves ].mstat;
			
				// Add to new activity count
				// act_counts[curr_node.act] += 1;
			
				curr_node.moves = curr_moves;
				curr_node.cx = x(curr_node.numchildren);
				curr_node.cy = y(curr_node.mstat);
			
				nodes[i].next_move_time += nodes[i].sched[ curr_node.moves ].duration;
			}

		});

		force.resume();
		curr_month += 1;

    /*

		// Update percentages
		svg.selectAll(".counter text")
			.text(function(d, i) {
				if (i == 0) {
					return "With Child " + readablePercent(75 - pstat_names[d].count); 
				} else {
					return readablePercent(75 - pstat_names[d].count); 
				}
			});
			
			*/

	
		// Update time
		var true_month = curr_month % last_month;
		d3.select("#current_time").text(monthsToAge(true_month));
		
		
		// Update notes
		// var true_month = curr_month % 1440;
		if (true_month == time_notes[notes_index].start_month) {
			d3.select("#note")
			  .transition()
				.duration(1000)
				.style("color", "#000000")
				.text(time_notes[notes_index].note);
		} 
		
		// Make note disappear at the end.
		else if (true_month == time_notes[notes_index].stop_month) {
			
			d3.select("#note").transition()
				.duration(1000)
				.style("color", "#ffffff");
				
			notes_index += 1;
			if (notes_index == time_notes.length) {
				notes_index = 0;
			}
		}
		
		setTimeout(timer, speeds[USER_SPEED]);
	}
	setTimeout(timer, speeds[USER_SPEED]);
	
	
	
		
	function tick(e) {
	  var k = 0.1 * e.alpha;
  
	  // Push nodes toward their designated focus.
	  nodes.forEach(function(o, i) {
		var curr_numchildren = o.numchildren;
		o.color = colorByGroup(o.grp);
		
		o.x += (x(o.numchildren) - o.x) * k * damper;
	    o.y += (y(o.mstat) - o.y) * k * damper;
	    
	  });

	  circle
	  	  .each(collide(.5))
	  	  .style("fill", function(d) { return d.color; })
	      .attr("cx", function(d) { return d.x; })
	      .attr("cy", function(d) { return d.y; });
	}


	// Resolve collisions between nodes.
	function collide(alpha) {
	  var quadtree = d3.geom.quadtree(nodes);
	  return function(d) {
	    var r = d.radius + radius + padding,
	        nx1 = d.x - r,
	        nx2 = d.x + r,
	        ny1 = d.y - r,
	        ny2 = d.y + r;
	    quadtree.visit(function(quad, x1, y1, x2, y2) {
	      if (quad.point && (quad.point !== d)) {
	        var x = d.x - quad.point.x,
	            y = d.y - quad.point.y,
	            l = Math.sqrt(x * x + y * y),
	            r = d.radius + quad.point.radius + (d.mstat !== quad.point.mstat) * padding;
	        if (l < r) {
	          l = (l - r) / l * alpha;
	          d.x -= x *= l;
	          d.y -= y *= l;
	          quad.point.x += x;
	          quad.point.y += y;
	        }
	      }
	      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
	    });
	  };
	}
	
	// Speed toggle
	d3.selectAll(".togglebutton")
      .on("click", function() {
        if (d3.select(this).attr("data-val") == "slow") {
            d3.select(".slow").classed("current", true);
			d3.select(".medium").classed("current", false);
            d3.select(".fast").classed("current", false);
        } else if (d3.select(this).attr("data-val") == "medium") {
            d3.select(".slow").classed("current", false);
			d3.select(".medium").classed("current", true);
            d3.select(".fast").classed("current", false);
        } 
		else {
            d3.select(".slow").classed("current", false);
			d3.select(".medium").classed("current", false);
			d3.select(".fast").classed("current", true);
        }
		
		USER_SPEED = d3.select(this).attr("data-val");
    });
}); // @end d3.tsv


function colorByGroup(occ) {

	return group_names[occ].color;
}


function colorByActivity(activity) {
	
	var color_by_activity = {
		"0": "#e0d400",
		"1": "#1c8af9",
		"2": "#51BC05",
		"3": "#FF7F00",
		"4": "#DB32A4",
		"5": "#00CDF8",
		"6": "#E63B60",
		"7": "#8E5649",
		"8": "#68c99e",
		"9": "#a477c8",
		"10": "#5C76EC",
		"11": "#E773C3",
		"12": "#799fd2",
		"13": "#038a6c",
		"14": "#cc87fa",
		"15": "#ee8e76",
		"16": "#bbbbbb",
	}
	
	return color_by_activity[activity];
	
}


function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1, // ems
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
      }
    }
  });
}



// Output readable percent based on count.
function readablePercent(n) {
	
	var pct = 100 * n / 75;
	if (pct < 1 && pct > 0) {
		pct = "<1%";
	} else {
		pct = Math.round(pct) + "%";
	}
	
	return pct;
}


// Months to age in years and fractions of year. Data is months from date of birth.
function monthsToAge(m) {
  var months = m + 180;
  var precise_age = months / 12
  var age = precise_age.toFixed(1);
	return "Age: " + age;
}


</script>